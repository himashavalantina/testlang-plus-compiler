package org.example;

import java.io.*;
import java.util.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

// ----------------------------------------------------------------------
// CODE GENERATOR
// ----------------------------------------------------------------------

/**
 * Reads the parsed AST and generates a runnable JUnit 5 Java test class.
 *
 * NOTE: For the final solution, we would ideally pass the AST root (Program)
 * generated by the parser. This method simulates that by accepting a Program object.
 */
public class CodeGenerator {
    private static final String OUTPUT_FILE = "src/test/java/com/testlang/generated/GeneratedTests.java";
    private static final String BASE_INDENT = "    "; // 4 spaces

    // Maps variable names to their string values
    private final Map<String, String> variables = new HashMap<>();

    // Default configuration values
    private String baseUrl = "http://localhost:8080";
    private final Map<String, String> defaultHeaders = new HashMap<>();

    public static void main(String[] args) {
        // --- CodeGenerator Execution Logic ---
        if (args.length == 0) {
            System.err.println("Usage: java CodeGenerator <test_file.test>");
            return;
        }

        try {
            // Placeholder: Simulate parsing the example file into a Program object.
            Program astRoot = createExampleAst(args[0]);

            CodeGenerator generator = new CodeGenerator();
            generator.generate(astRoot);
            System.out.println("âœ… Successfully generated " + OUTPUT_FILE);
            System.out.println("  (Ensure " + args[0] + " was correctly parsed to match the sample AST.)");

        } catch (IOException e) {
            System.err.println("Error reading or writing file: " + e.getMessage());
        } catch (Exception e) {
            System.err.println("Compilation/Generation Error: " + e.getMessage());
            e.printStackTrace();
        }
    }

    /**
     * Traverses the AST and writes the Java code.
     * @param program The root of the AST.
     * @throws IOException If file writing fails.
     */
    public void generate(Program program) throws IOException {
        Path outPath = Paths.get(OUTPUT_FILE);
        Files.createDirectories(outPath.getParent());
        try (PrintWriter writer = new PrintWriter(OUTPUT_FILE)) {
            // 1. Process config and variable declarations
            processConfig(program.config);
            processVariables(program.variables);

            // 2. Generate header and setup
            generatePreamble(writer);
            generateSetupMethod(writer);
            generateHelperMethods(writer);

            // 3. Generate test methods
            for (TestBlock test : program.tests) {
                generateTest(writer, test);
            }

            // 4. Close class
            writer.println("}");
        }
    }

    // ---------------------- AST PROCESSING ----------------------

    private void processConfig(ConfigBlock config) {
        if (config == null) return;
        for (ConfigStatement stmt : config.statements) {
            if (stmt.type == ConfigStatement.Type.BASE_URL) {
                this.baseUrl = stmt.value;
            } else if (stmt.type == ConfigStatement.Type.DEFAULT_HEADER) {
                this.defaultHeaders.put(stmt.key, stmt.value);
            }
        }
    }

    private void processVariables(List<VarDecl> vars) {
        for (VarDecl var : vars) {
            // Apply interpolation to variable values themselves
            String value = interpolate(var.value, variables);
            this.variables.put(var.name, value);
        }
    }

    /**
     * Replaces $variable with its value in a string.
     * @param input The string to interpolate.
     * @param vars The map of variables.
     * @return The interpolated string.
     */
    private String interpolate(String input, Map<String, String> vars) {
        String result = input;
        // Simple regex to find $name or ${name}
        Pattern pattern = Pattern.compile("\\$(\\w+)");
        Matcher matcher = pattern.matcher(result);

        // Find and replace all matches
        while (matcher.find()) {
            String varName = matcher.group(1);
            if (vars.containsKey(varName)) {
                // Replace the found $varName with the actual value
                result = result.replace(matcher.group(0), vars.get(varName));
                // Reset matcher to search in the new string
                matcher = pattern.matcher(result);
            }
        }
        return result;
    }


    // ---------------------- CODE GENERATION ----------------------

    private void generatePreamble(PrintWriter writer) {
        writer.println("/**");
        writer.println(" * GeneratedTests.java");
        writer.println(" * DO NOT MODIFY. This file is automatically generated by the TestLang++ Compiler.");
        writer.println(" */");
        writer.println("package com.testlang.generated;");
        writer.println();
        writer.println("import org.junit.jupiter.api.*;");
        writer.println("import static org.junit.jupiter.api.Assertions.*;");
        writer.println("import java.net.http.*;");
        writer.println("import java.net.URI;");
        writer.println("import java.io.IOException;");
        writer.println("import java.util.Map;");
        writer.println("import java.util.concurrent.ConcurrentHashMap;");
        writer.println("import java.util.regex.*;");
        writer.println();
        writer.println("@TestInstance(TestInstance.Lifecycle.PER_CLASS)");
        writer.println("public class GeneratedTests {");
        writer.println();
        writer.println(BASE_INDENT + "private static HttpClient client;");
        writer.println(BASE_INDENT + "private static String baseUrl = \"" + baseUrl + "\";");
        writer.println(BASE_INDENT + "private static Map<String, String> defaultHeaders = new ConcurrentHashMap<>();");
        writer.println(BASE_INDENT + "private static Map<String, String> globalVars = new ConcurrentHashMap<>();");
        writer.println();
    }

    private void generateSetupMethod(PrintWriter writer) {
        writer.println(BASE_INDENT + "@BeforeAll");
        writer.println(BASE_INDENT + "void setup() {");
        writer.println(BASE_INDENT + BASE_INDENT + "// Initialize HttpClient with default settings");
        writer.println(BASE_INDENT + BASE_INDENT + "client = HttpClient.newBuilder()");
        writer.println(BASE_INDENT + BASE_INDENT + "    .version(HttpClient.Version.HTTP_2)");
        writer.println(BASE_INDENT + BASE_INDENT + "    .build();");
        writer.println();

        // Add default headers from config
        writer.println(BASE_INDENT + BASE_INDENT + "// Load default headers from TestLang++ config");
        for (Map.Entry<String, String> entry : defaultHeaders.entrySet()) {
            writer.println(BASE_INDENT + BASE_INDENT + "defaultHeaders.put(\"" + entry.getKey() + "\", \"" + entry.getValue() + "\");");
        }
        // Initialize globalVars with declared variables
        writer.println(BASE_INDENT + BASE_INDENT + "// Load global variables from 'let' statements");
        for (Map.Entry<String, String> entry : variables.entrySet()) {
            writer.println(BASE_INDENT + BASE_INDENT + "globalVars.put(\"" + entry.getKey() + "\", \"" + entry.getValue().replace("\\", "\\\\").replace("\"", "\\\"") + "\");");
        }
        writer.println(BASE_INDENT + "}");
        writer.println();
    }

    private void generateHelperMethods(PrintWriter writer) {
        // Interpolate method
        writer.println(BASE_INDENT + "private static String interpolate(String input, Map<String,String> runtime, Map<String,String> globals) {");
        writer.println(BASE_INDENT + BASE_INDENT + "if (input == null) return null;");
        writer.println(BASE_INDENT + BASE_INDENT + "Pattern p = Pattern.compile(\"\\\\$\\\\w+\");");
        writer.println(BASE_INDENT + BASE_INDENT + "Matcher m = p.matcher(input);");
        writer.println(BASE_INDENT + BASE_INDENT + "StringBuffer sb = new StringBuffer();");
        writer.println(BASE_INDENT + BASE_INDENT + "while (m.find()) { ");
        writer.println(BASE_INDENT + BASE_INDENT + BASE_INDENT + "String name = m.group().substring(1);");
        writer.println(BASE_INDENT + BASE_INDENT + BASE_INDENT + "String val = runtime.get(name);");
        writer.println(BASE_INDENT + BASE_INDENT + BASE_INDENT + "if (val == null) val = globals.get(name);");
        writer.println(BASE_INDENT + BASE_INDENT + BASE_INDENT + "if (val == null) val = m.group(); // leave as-is if unknown");
        writer.println(BASE_INDENT + BASE_INDENT + BASE_INDENT + "m.appendReplacement(sb, Matcher.quoteReplacement(val));");
        writer.println(BASE_INDENT + BASE_INDENT + "}");
        writer.println(BASE_INDENT + BASE_INDENT + "m.appendTail(sb);");
        writer.println(BASE_INDENT + BASE_INDENT + "return sb.toString();");
        writer.println(BASE_INDENT + "}");
        writer.println();

        // Simple JSON string extractor by key (assumes flat string field)
        writer.println(BASE_INDENT + "private static String extractJsonString(String json, String key) {");
        writer.println(BASE_INDENT + BASE_INDENT + "if (json == null || key == null) return \"\";");
        writer.println(BASE_INDENT + BASE_INDENT + "// Regex to find \"key\": \"value\" and capture value");
        writer.println(BASE_INDENT + BASE_INDENT + "Pattern p = Pattern.compile(\"\\\\\\\"\" + Pattern.quote(key) + \"\\\\\\\"\\\\s*:\\\\s*\\\\\\\"([^\\\\\\\"]*)\\\\\\\"\");");
        writer.println(BASE_INDENT + BASE_INDENT + "Matcher m = p.matcher(json);");
        writer.println(BASE_INDENT + BASE_INDENT + "if (m.find()) return m.group(1);");
        writer.println(BASE_INDENT + BASE_INDENT + "return \"\";");
        writer.println(BASE_INDENT + "}");
        writer.println();
    }

    private void generateTest(PrintWriter writer, TestBlock test) {
        // Method signature
        writer.println(BASE_INDENT + "@Test");
        writer.println(BASE_INDENT + "void test_" + test.name + "() throws IOException, InterruptedException {");
        writer.println(BASE_INDENT + BASE_INDENT + "HttpResponse<String> response = null;");
        writer.println(BASE_INDENT + BASE_INDENT + "HttpRequest.Builder requestBuilder;");
        // runtimeVars store variables captured during the test run (e.g., tokens)
        writer.println(BASE_INDENT + BASE_INDENT + "Map<String,String> runtimeVars = new ConcurrentHashMap<>();");
        writer.println();

        // Generate statements, chaining request/response
        for (TestStatement stmt : test.statements) {
            if (stmt instanceof RequestStatement) {
                generateRequest(writer, (RequestStatement) stmt);
            } else if (stmt instanceof AssertionStatement) {
                // Assertions always assert against the LAST 'response' object
                generateAssertion(writer, (AssertionStatement) stmt);
            } else if (stmt instanceof CaptureStatement) {
                // Captures always use the LAST 'response' object and update runtimeVars
                generateCapture(writer, (CaptureStatement) stmt);
            }
        }

        writer.println(BASE_INDENT + "}");
        writer.println();
    }

    private void generateRequest(PrintWriter writer, RequestStatement req) {
        // Use runtime interpolation inside generated code
        String escapedPath = req.path.replace("\\", "\\\\").replace("\"", "\\\"");

        writer.println(BASE_INDENT + BASE_INDENT + "// --- Start Request: " + req.method + " " + req.path + " ---");
        writer.println(BASE_INDENT + BASE_INDENT + "String __path = interpolate(\"" + escapedPath + "\", runtimeVars, globalVars);");
        writer.println(BASE_INDENT + BASE_INDENT + "requestBuilder = HttpRequest.newBuilder()");
        writer.println(BASE_INDENT + BASE_INDENT + "    .uri(URI.create(baseUrl + __path));");

        // 1. Add Default Headers
        writer.println(BASE_INDENT + BASE_INDENT + "defaultHeaders.forEach(requestBuilder::header);");

        // 2. Add Request-Specific Headers
        if (req.details != null && !req.details.headers.isEmpty()) {
            writer.println(BASE_INDENT + BASE_INDENT + "// Add specific headers (runtime interpolated)");
            for (HeaderStatement header : req.details.headers) {
                String escapedValue = header.value.replace("\\", "\\\\").replace("\"", "\\\"");
                writer.println(BASE_INDENT + BASE_INDENT + "requestBuilder.header(\"" + header.key + "\", interpolate(\"" + escapedValue + "\", runtimeVars, globalVars));");
            }
        }

        // 3. Set Body and Method
        String body = req.details != null ? req.details.body : null;
        if (body != null) {
            // Escape Java string literal content, interpolate at runtime
            String escapedBody = body.replace("\\", "\\\\").replace("\"", "\\\"");
            writer.println(BASE_INDENT + BASE_INDENT + "String requestBody = interpolate(\"" + escapedBody + "\", runtimeVars, globalVars);");
            writer.println(BASE_INDENT + BASE_INDENT + "HttpRequest.BodyPublisher bodyPublisher = HttpRequest.BodyPublishers.ofString(requestBody);");
        } else {
            writer.println(BASE_INDENT + BASE_INDENT + "HttpRequest.BodyPublisher bodyPublisher;");
        }

        switch (req.method) {
            case GET:
                writer.println(BASE_INDENT + BASE_INDENT + "requestBuilder.GET();");
                break;
            case POST:
                // POST requires a body, even if empty. If no body provided, send an empty one.
                if (body != null) {
                    writer.println(BASE_INDENT + BASE_INDENT + "requestBuilder.POST(bodyPublisher);");
                } else {
                    writer.println(BASE_INDENT + BASE_INDENT + "requestBuilder.POST(HttpRequest.BodyPublishers.noBody());");
                }
                break;
            case PUT:
                // PUT requires a body, even if empty.
                if (body != null) {
                    writer.println(BASE_INDENT + BASE_INDENT + "requestBuilder.PUT(bodyPublisher);");
                } else {
                    writer.println(BASE_INDENT + BASE_INDENT + "requestBuilder.PUT(HttpRequest.BodyPublishers.noBody());");
                }
                break;
            case DELETE:
                // DELETE typically has no body. If body exists, must use builder.method()
                if (body != null) {
                    writer.println(BASE_INDENT + BASE_INDENT + "requestBuilder.method(\"DELETE\", bodyPublisher);");
                } else {
                    writer.println(BASE_INDENT + BASE_INDENT + "requestBuilder.DELETE();");
                }
                break;
        }

        // 4. Send Request and store Response
        writer.println(BASE_INDENT + BASE_INDENT + "response = client.send(requestBuilder.build(), HttpResponse.BodyHandlers.ofString());");
        writer.println(BASE_INDENT + BASE_INDENT + "// --- End Request ---");
        writer.println();
    }

    private void generateCapture(PrintWriter writer, CaptureStatement cap) {
        if (cap.type == CaptureStatement.Type.BODY) {
            writer.println(BASE_INDENT + BASE_INDENT + "// Capture from response body: JSON key '" + cap.key + "' into runtime variable $" + cap.varName);
            String escapedKey = cap.key.replace("\\", "\\\\").replace("\"", "\\\"");
            writer.println(BASE_INDENT + BASE_INDENT + "String __captured = extractJsonString(response.body(), \"" + escapedKey + "\");");
            writer.println(BASE_INDENT + BASE_INDENT + "runtimeVars.put(\"" + cap.varName + "\", __captured);");
            writer.println();
        } else if (cap.type == CaptureStatement.Type.HEADER) {
            writer.println(BASE_INDENT + BASE_INDENT + "// Capture from response header: '" + cap.key + "' into runtime variable $" + cap.varName);
            writer.println(BASE_INDENT + BASE_INDENT + "String __captured = response.headers().firstValue(\"" + cap.key.replace("\"","\\\"") + "\").orElse(\"\");");
            writer.println(BASE_INDENT + BASE_INDENT + "runtimeVars.put(\"" + cap.varName + "\", __captured);");
            writer.println();
        }
    }

    private void generateAssertion(PrintWriter writer, AssertionStatement assertion) {
        writer.println(BASE_INDENT + BASE_INDENT + "// Assertion: " + assertion.getClass().getSimpleName());

        if (assertion instanceof StatusAssertion) {
            StatusAssertion sa = (StatusAssertion) assertion;
            if (sa.type == StatusAssertion.Type.EQ) {
                writer.println(BASE_INDENT + BASE_INDENT + "assertEquals(" + sa.value + ", response.statusCode(), \"Status code mismatch\");");
            } else if (sa.type == StatusAssertion.Type.IN_RANGE) {
                Range r = (Range) sa.value;
                writer.println(BASE_INDENT + BASE_INDENT + "assertTrue(response.statusCode() >= " + r.low + " && response.statusCode() <= " + r.high + ", \"Status code not in range [" + r.low + ".." + r.high + "]\");");
            }
        } else if (assertion instanceof HeaderAssertion) {
            HeaderAssertion ha = (HeaderAssertion) assertion;
            // The assertion value itself must be interpolated from global vars, not runtime vars, for consistency
            String interpolatedValue = interpolate(ha.value, variables);
            String escapedValue = interpolatedValue.replace("\"", "\\\"");

            writer.println(BASE_INDENT + BASE_INDENT + "String actualHeader = response.headers().firstValue(\"" + ha.key + "\").orElse(\"\");");
            if (ha.type == HeaderAssertion.Type.EQ) {
                writer.println(BASE_INDENT + BASE_INDENT + "assertEquals(\"" + escapedValue + "\", actualHeader, \"Header '" + ha.key + "' value mismatch\");");
            } else if (ha.type == HeaderAssertion.Type.CONTAINS) {
                writer.println(BASE_INDENT + BASE_INDENT + "assertTrue(actualHeader.contains(\"" + escapedValue + "\"), \"Header '" + ha.key + "' does not contain '" + escapedValue + "'\");");
            }
        } else if (assertion instanceof BodyAssertion) {
            BodyAssertion ba = (BodyAssertion) assertion;
            // The assertion value itself must be interpolated from global vars
            String interpolatedValue = interpolate(ba.value, variables);
            String escapedValue = interpolatedValue.replace("\"", "\\\"");

            if (ba.type == BodyAssertion.Type.CONTAINS) {
                writer.println(BASE_INDENT + BASE_INDENT + "assertTrue(response.body().contains(\"" + escapedValue + "\"), \"Response body does not contain expected text.\");");
            }
        }
        writer.println();
    }

    // ----------------------------------------------------------------------
    // FIXED SIMULATION: Helper to build the example AST for demonstration
    // ----------------------------------------------------------------------
    private static Program createExampleAst(String filename) {
        // This is a placeholder that simulates the parser's output for the example.test content.

        // 1. Config Block
        ConfigBlock config = new ConfigBlock();
        config.addStatement(new ConfigStatement(ConfigStatement.Type.BASE_URL, "http://localhost:8080"));
        config.addStatement(new ConfigStatement(ConfigStatement.Type.DEFAULT_HEADER, "Content-Type", "application/json"));
        config.addStatement(new ConfigStatement(ConfigStatement.Type.DEFAULT_HEADER, "Accept", "application/json"));

        // 2. Variable Declarations
        List<VarDecl> vars = new ArrayList<>();
        vars.add(new VarDecl("user_email", "test@example.com"));
        vars.add(new VarDecl("user_password", "P@ssword123"));

        // 3. Test Blocks
        List<TestBlock> tests = new ArrayList<>();

        // --- Test 1: Successful Login (POST) ---
        List<TestStatement> loginStmts = new ArrayList<>();
        List<HeaderStatement> loginHeaders = new ArrayList<>();
        // Note: Removing "Content-Type" from default headers if it's not the default type for the login!
        // Here we assume it's JSON by default, but for the login endpoint, we override it.
        loginHeaders.add(new HeaderStatement("Content-Type", "application/x-www-form-urlencoded")); 
        
        RequestDetails loginDetails = new RequestDetails(
            loginHeaders,
            "username=$user_email&password=$user_password" // Form-data body
        );
        loginStmts.add(new RequestStatement(RequestStatement.Method.POST, "/login", loginDetails));
        loginStmts.add(new StatusAssertion(StatusAssertion.Type.EQ, 200, null));
        loginStmts.add(new BodyAssertion(BodyAssertion.Type.CONTAINS, "token", null));
        // CRITICAL: Capture the dynamically generated token into runtime variable 'session_token'
        loginStmts.add(new CaptureStatement(CaptureStatement.Type.BODY, "token", "session_token"));
        tests.add(new TestBlock("SuccessfulLogin", loginStmts));

        // --- Test 2: Get User Profile (GET) ---
        List<TestStatement> getUserStmts = new ArrayList<>();
        // Use the captured token via runtime interpolation
        List<HeaderStatement> authHeader = new ArrayList<>();
        // IMPORTANT: The variable $session_token is created at RUNTIME, so the code generator MUST use runtime interpolation!
        authHeader.add(new HeaderStatement("Authorization", "Bearer $session_token")); 
        RequestDetails getUserDetails = new RequestDetails(authHeader, null);

        getUserStmts.add(new RequestStatement(RequestStatement.Method.GET, "/user/profile", getUserDetails));
        getUserStmts.add(new StatusAssertion(StatusAssertion.Type.IN_RANGE, new Range(200, 299), null)); 
        getUserStmts.add(new HeaderAssertion(HeaderAssertion.Type.EQ, "Content-Type", "application/json", null));
        getUserStmts.add(new BodyAssertion(BodyAssertion.Type.CONTAINS, "$user_email", null));
        tests.add(new TestBlock("GetUserProfile", getUserStmts));


        return new Program(config, vars, tests);
    }
}